From 709250334137bcb17c08c5a78ded380ea3b64d81 Mon Sep 17 00:00:00 2001
From: openhands <openhands@all-hands.dev>
Date: Wed, 13 Aug 2025 07:49:05 +0000
Subject: [PATCH 1/3] feat: Add complete Gitea integration with frontend and
 backend support

## Backend Implementation
- Add GITEA to ProviderType enum in service_types.py
- Add Gitea provider terms to SuggestedTask.get_provider_terms()
- Create GiteaService class with full GitHub API-compatible implementation
- Register Gitea in ProviderHandler (PROVIDER_DOMAINS and service_class_map)
- Add Gitea support to validate_provider_token function
- Add Gitea authenticated git URL generation
- Create Gitea microagent documentation

## Frontend Implementation
- Add 'gitea' to ProviderOptions type in settings.ts
- Create GiteaTokenInput and GiteaTokenHelpAnchor components
- Add comprehensive i18n support with all required keys and translations
- Integrate Gitea token input into git-settings page with full state management
- Fix TypeScript errors and ensure type safety across all components

## Features
- Complete API compatibility with Gitea instances
- Token validation and authentication
- Repository management (list, search, details, branches)
- Microagent support for Gitea repositories
- User authentication and profile management
- Consistent UI/UX with existing Git providers
- Full internationalization support

## Testing
- Backend: All core functionality verified (provider registration, service instantiation, token validation)
- Frontend: TypeScript compilation and build process successful
- Integration: All components properly connected and functional

Co-authored-by: openhands <openhands@all-hands.dev>
---
 .../git-settings/gitea-token-help-anchor.tsx  |  32 ++
 .../git-settings/gitea-token-input.tsx        |  67 ++++
 .../conversation-subscriptions-provider.tsx   |   4 +-
 frontend/src/i18n/declaration.ts              |   8 +
 frontend/src/i18n/translation.json            | 128 +++++++
 frontend/src/routes/git-settings.tsx          |  32 +-
 frontend/src/routes/settings.tsx              |   3 +-
 frontend/src/types/settings.ts                |   1 +
 microagents/gitea.md                          |  84 +++++
 openhands/integrations/gitea/__init__.py      |   0
 openhands/integrations/gitea/gitea_service.py | 341 ++++++++++++++++++
 openhands/integrations/provider.py            |   8 +-
 openhands/integrations/service_types.py       |  11 +
 openhands/integrations/utils.py               |  17 +-
 14 files changed, 726 insertions(+), 10 deletions(-)
 create mode 100644 frontend/src/components/features/settings/git-settings/gitea-token-help-anchor.tsx
 create mode 100644 frontend/src/components/features/settings/git-settings/gitea-token-input.tsx
 create mode 100644 microagents/gitea.md
 create mode 100644 openhands/integrations/gitea/__init__.py
 create mode 100644 openhands/integrations/gitea/gitea_service.py

diff --git a/frontend/src/components/features/settings/git-settings/gitea-token-help-anchor.tsx b/frontend/src/components/features/settings/git-settings/gitea-token-help-anchor.tsx
new file mode 100644
index 000000000000..fd0f8fbe9389
--- /dev/null
+++ b/frontend/src/components/features/settings/git-settings/gitea-token-help-anchor.tsx
@@ -0,0 +1,32 @@
+import { Trans, useTranslation } from "react-i18next";
+import { I18nKey } from "#/i18n/declaration";
+
+export function GiteaTokenHelpAnchor() {
+  const { t } = useTranslation();
+
+  return (
+    <p data-testid="gitea-token-help-anchor" className="text-xs">
+      <Trans
+        i18nKey={I18nKey.GITEA$TOKEN_HELP_TEXT}
+        components={[
+          <a
+            key="gitea-token-help-anchor-link"
+            aria-label={t(I18nKey.GIT$GITEA_TOKEN_HELP_LINK)}
+            href="https://docs.gitea.com/development/api-usage#authentication"
+            target="_blank"
+            className="underline underline-offset-2"
+            rel="noopener noreferrer"
+          />,
+          <a
+            key="gitea-token-help-anchor-link-2"
+            aria-label={t(I18nKey.GIT$GITEA_TOKEN_SEE_MORE_LINK)}
+            href="https://docs.gitea.com/usage/api-usage"
+            target="_blank"
+            className="underline underline-offset-2"
+            rel="noopener noreferrer"
+          />,
+        ]}
+      />
+    </p>
+  );
+}
diff --git a/frontend/src/components/features/settings/git-settings/gitea-token-input.tsx b/frontend/src/components/features/settings/git-settings/gitea-token-input.tsx
new file mode 100644
index 000000000000..cffa76457552
--- /dev/null
+++ b/frontend/src/components/features/settings/git-settings/gitea-token-input.tsx
@@ -0,0 +1,67 @@
+import { useTranslation } from "react-i18next";
+import { I18nKey } from "#/i18n/declaration";
+import { SettingsInput } from "../settings-input";
+import { GiteaTokenHelpAnchor } from "./gitea-token-help-anchor";
+import { KeyStatusIcon } from "../key-status-icon";
+import { cn } from "#/utils/utils";
+
+interface GiteaTokenInputProps {
+  onChange: (value: string) => void;
+  onGiteaHostChange: (value: string) => void;
+  isGiteaTokenSet: boolean;
+  name: string;
+  giteaHostSet: string | null | undefined;
+  className?: string;
+}
+
+export function GiteaTokenInput({
+  onChange,
+  onGiteaHostChange,
+  isGiteaTokenSet,
+  name,
+  giteaHostSet,
+  className,
+}: GiteaTokenInputProps) {
+  const { t } = useTranslation();
+
+  return (
+    <div className={cn("flex flex-col gap-6", className)}>
+      <SettingsInput
+        testId={name}
+        name={name}
+        onChange={onChange}
+        label={t(I18nKey.GITEA$TOKEN_LABEL)}
+        type="password"
+        className="w-full max-w-[680px]"
+        placeholder={isGiteaTokenSet ? "<hidden>" : ""}
+        startContent={
+          isGiteaTokenSet && (
+            <KeyStatusIcon
+              testId="gitea-set-token-indicator"
+              isSet={isGiteaTokenSet}
+            />
+          )
+        }
+      />
+
+      <SettingsInput
+        onChange={onGiteaHostChange || (() => {})}
+        name="gitea-host-input"
+        testId="gitea-host-input"
+        label={t(I18nKey.GITEA$HOST_LABEL)}
+        type="text"
+        className="w-full max-w-[680px]"
+        placeholder="gitea.com"
+        defaultValue={giteaHostSet || undefined}
+        startContent={
+          giteaHostSet &&
+          giteaHostSet.trim() !== "" && (
+            <KeyStatusIcon testId="gitea-set-host-indicator" isSet />
+          )
+        }
+      />
+
+      <GiteaTokenHelpAnchor />
+    </div>
+  );
+}
diff --git a/frontend/src/context/conversation-subscriptions-provider.tsx b/frontend/src/context/conversation-subscriptions-provider.tsx
index 36ebe3e1900d..5317030a5d00 100644
--- a/frontend/src/context/conversation-subscriptions-provider.tsx
+++ b/frontend/src/context/conversation-subscriptions-provider.tsx
@@ -31,7 +31,7 @@ interface ConversationSubscriptionsContextType {
   subscribeToConversation: (options: {
     conversationId: string;
     sessionApiKey: string | null;
-    providersSet: ("github" | "gitlab" | "bitbucket" | "enterprise_sso")[];
+    providersSet: ("github" | "gitlab" | "bitbucket" | "gitea" | "enterprise_sso")[];
     baseUrl: string;
     onEvent?: (event: unknown, conversationId: string) => void;
   }) => void;
@@ -135,7 +135,7 @@ export function ConversationSubscriptionsProvider({
     (options: {
       conversationId: string;
       sessionApiKey: string | null;
-      providersSet: ("github" | "gitlab" | "bitbucket" | "enterprise_sso")[];
+      providersSet: ("github" | "gitlab" | "bitbucket" | "gitea" | "enterprise_sso")[];
       baseUrl: string;
       onEvent?: (event: unknown, conversationId: string) => void;
     }) => {
diff --git a/frontend/src/i18n/declaration.ts b/frontend/src/i18n/declaration.ts
index a6df1caf48e0..8b06c11ea06f 100644
--- a/frontend/src/i18n/declaration.ts
+++ b/frontend/src/i18n/declaration.ts
@@ -585,6 +585,12 @@ export enum I18nKey {
   BITBUCKET$TOKEN_HELP_TEXT = "BITBUCKET$TOKEN_HELP_TEXT",
   BITBUCKET$TOKEN_LINK_TEXT = "BITBUCKET$TOKEN_LINK_TEXT",
   BITBUCKET$INSTRUCTIONS_LINK_TEXT = "BITBUCKET$INSTRUCTIONS_LINK_TEXT",
+  GITEA$TOKEN_LABEL = "GITEA$TOKEN_LABEL",
+  GITEA$HOST_LABEL = "GITEA$HOST_LABEL",
+  GITEA$GET_TOKEN = "GITEA$GET_TOKEN",
+  GITEA$TOKEN_HELP_TEXT = "GITEA$TOKEN_HELP_TEXT",
+  GITEA$TOKEN_LINK_TEXT = "GITEA$TOKEN_LINK_TEXT",
+  GITEA$INSTRUCTIONS_LINK_TEXT = "GITEA$INSTRUCTIONS_LINK_TEXT",
   GITLAB$OR_SEE = "GITLAB$OR_SEE",
   AGENT_ERROR$ERROR_ACTION_NOT_EXECUTED_STOPPED = "AGENT_ERROR$ERROR_ACTION_NOT_EXECUTED_STOPPED",
   AGENT_ERROR$ERROR_ACTION_NOT_EXECUTED_ERROR = "AGENT_ERROR$ERROR_ACTION_NOT_EXECUTED_ERROR",
@@ -669,6 +675,8 @@ export enum I18nKey {
   GIT$GITHUB_TOKEN_SEE_MORE_LINK = "GIT$GITHUB_TOKEN_SEE_MORE_LINK",
   GIT$GITLAB_TOKEN_HELP_LINK = "GIT$GITLAB_TOKEN_HELP_LINK",
   GIT$GITLAB_TOKEN_SEE_MORE_LINK = "GIT$GITLAB_TOKEN_SEE_MORE_LINK",
+  GIT$GITEA_TOKEN_HELP_LINK = "GIT$GITEA_TOKEN_HELP_LINK",
+  GIT$GITEA_TOKEN_SEE_MORE_LINK = "GIT$GITEA_TOKEN_SEE_MORE_LINK",
   SECRETS$SECRET_ALREADY_EXISTS = "SECRETS$SECRET_ALREADY_EXISTS",
   SECRETS$API_KEY_EXAMPLE = "SECRETS$API_KEY_EXAMPLE",
   MODEL$CUSTOM_MODEL = "MODEL$CUSTOM_MODEL",
diff --git a/frontend/src/i18n/translation.json b/frontend/src/i18n/translation.json
index 4fc021f17739..78914ff4478a 100644
--- a/frontend/src/i18n/translation.json
+++ b/frontend/src/i18n/translation.json
@@ -9359,6 +9359,102 @@
         "de": "klicken Sie hier für Anweisungen",
         "uk": "натисніть тут, щоб отримати інструкції"
     },
+    "GITEA$TOKEN_LABEL": {
+        "en": "Gitea Token",
+        "ja": "Giteaトークン",
+        "zh-CN": "Gitea令牌",
+        "zh-TW": "Gitea權杖",
+        "ko-KR": "Gitea 토큰",
+        "no": "Gitea-token",
+        "it": "Token Gitea",
+        "pt": "Token do Gitea",
+        "es": "Token de Gitea",
+        "ar": "رمز Gitea",
+        "fr": "Token Gitea",
+        "tr": "Gitea Jetonu",
+        "de": "Gitea-Token",
+        "uk": "Токен Gitea"
+    },
+    "GITEA$HOST_LABEL": {
+        "en": "Gitea Host",
+        "ja": "Giteaホスト",
+        "zh-CN": "Gitea主机",
+        "zh-TW": "Gitea主機",
+        "ko-KR": "Gitea 호스트",
+        "no": "Gitea-vert",
+        "it": "Host Gitea",
+        "pt": "Host do Gitea",
+        "es": "Host de Gitea",
+        "ar": "مضيف Gitea",
+        "fr": "Hôte Gitea",
+        "tr": "Gitea Ana Bilgisayarı",
+        "de": "Gitea-Host",
+        "uk": "Хост Gitea"
+    },
+    "GITEA$GET_TOKEN": {
+        "en": "Get your Gitea token",
+        "ja": "Giteaトークンを取得",
+        "zh-CN": "获取您的Gitea令牌",
+        "zh-TW": "獲取您的Gitea權杖",
+        "ko-KR": "Gitea 토큰 받기",
+        "no": "Få ditt Gitea-token",
+        "it": "Ottieni il tuo token Gitea",
+        "pt": "Obtenha seu token do Gitea",
+        "es": "Obtén tu token de Gitea",
+        "ar": "احصل على رمز Gitea الخاص بك",
+        "fr": "Obtenez votre token Gitea",
+        "tr": "Gitea jetonunuzu alın",
+        "de": "Holen Sie sich Ihr Gitea-Token",
+        "uk": "Отримайте свій токен Gitea"
+    },
+    "GITEA$TOKEN_HELP_TEXT": {
+        "en": "To create a Gitea token, <0>click here</0> or <1>see the documentation</1>.",
+        "ja": "Giteaトークンを作成するには、<0>ここをクリック</0>するか、<1>ドキュメントを参照</1>してください。",
+        "zh-CN": "要创建Gitea令牌，<0>点击此处</0>或<1>查看文档</1>。",
+        "zh-TW": "要創建Gitea權杖，<0>點擊此處</0>或<1>查看文檔</1>。",
+        "ko-KR": "Gitea 토큰을 생성하려면 <0>여기를 클릭</0>하거나 <1>문서를 참조</1>하세요.",
+        "no": "For å opprette et Gitea-token, <0>klikk her</0> eller <1>se dokumentasjonen</1>.",
+        "it": "Per creare un token Gitea, <0>clicca qui</0> o <1>vedi la documentazione</1>.",
+        "pt": "Para criar um token do Gitea, <0>clique aqui</0> ou <1>veja a documentação</1>.",
+        "es": "Para crear un token de Gitea, <0>haga clic aquí</0> o <1>vea la documentación</1>.",
+        "ar": "لإنشاء رمز Gitea، <0>انقر هنا</0> أو <1>راجع الوثائق</1>.",
+        "fr": "Pour créer un token Gitea, <0>cliquez ici</0> ou <1>consultez la documentation</1>.",
+        "tr": "Bir Gitea jetonu oluşturmak için <0>buraya tıklayın</0> veya <1>belgelere bakın</1>.",
+        "de": "Um ein Gitea-Token zu erstellen, <0>klicken Sie hier</0> oder <1>sehen Sie sich die Dokumentation an</1>.",
+        "uk": "Щоб створити токен Gitea, <0>натисніть тут</0> або <1>перегляньте документацію</1>."
+    },
+    "GITEA$TOKEN_LINK_TEXT": {
+        "en": "click here",
+        "ja": "ここをクリック",
+        "zh-CN": "点击此处",
+        "zh-TW": "點擊此處",
+        "ko-KR": "여기를 클릭",
+        "no": "klikk her",
+        "it": "clicca qui",
+        "pt": "clique aqui",
+        "es": "haga clic aquí",
+        "ar": "انقر هنا",
+        "fr": "cliquez ici",
+        "tr": "buraya tıklayın",
+        "de": "klicken Sie hier",
+        "uk": "натисніть тут"
+    },
+    "GITEA$INSTRUCTIONS_LINK_TEXT": {
+        "en": "click here for instructions",
+        "ja": "手順についてはここをクリック",
+        "zh-CN": "点击此处获取说明",
+        "zh-TW": "點擊此處獲取說明",
+        "ko-KR": "지침을 보려면 여기를 클릭",
+        "no": "klikk her for instruksjoner",
+        "it": "clicca qui per istruzioni",
+        "pt": "clique aqui para instruções",
+        "es": "haga clic aquí para obtener instrucciones",
+        "ar": "انقر هنا للحصول على تعليمات",
+        "fr": "cliquez ici pour les instructions",
+        "tr": "talimatlar için buraya tıklayın",
+        "de": "klicken Sie hier für Anweisungen",
+        "uk": "натисніть тут, щоб отримати інструкції"
+    },
     "GITLAB$OR_SEE": {
         "en": "or see the",
         "ja": "または参照",
@@ -10703,6 +10799,38 @@
         "de": "GitLab-Token mehr sehen Link",
         "uk": "Посилання для перегляду більше про токен GitLab"
     },
+    "GIT$GITEA_TOKEN_HELP_LINK": {
+        "en": "Gitea token help link",
+        "ja": "Giteaトークンヘルプリンク",
+        "zh-CN": "Gitea令牌帮助链接",
+        "zh-TW": "Gitea令牌幫助連結",
+        "ko-KR": "Gitea 토큰 도움말 링크",
+        "no": "Gitea token hjelp lenke",
+        "it": "Link di aiuto per il token Gitea",
+        "pt": "Link de ajuda do token Gitea",
+        "es": "Enlace de ayuda del token de Gitea",
+        "ar": "رابط مساعدة رمز Gitea",
+        "fr": "Lien d'aide pour le jeton Gitea",
+        "tr": "Gitea token yardım bağlantısı",
+        "de": "Gitea-Token Hilfe-Link",
+        "uk": "Посилання на довідку токена Gitea"
+    },
+    "GIT$GITEA_TOKEN_SEE_MORE_LINK": {
+        "en": "Gitea token see more link",
+        "ja": "Giteaトークン詳細リンク",
+        "zh-CN": "Gitea令牌查看更多链接",
+        "zh-TW": "Gitea令牌查看更多連結",
+        "ko-KR": "Gitea 토큰 더 보기 링크",
+        "no": "Gitea token se mer lenke",
+        "it": "Link per vedere di più sul token Gitea",
+        "pt": "Link para ver mais sobre o token Gitea",
+        "es": "Enlace para ver más del token de Gitea",
+        "ar": "رابط لرؤية المزيد حول رمز Gitea",
+        "fr": "Lien pour en voir plus sur le jeton Gitea",
+        "tr": "Gitea token daha fazla görme bağlantısı",
+        "de": "Gitea-Token mehr sehen Link",
+        "uk": "Посилання для перегляду більше про токен Gitea"
+    },
     "SECRETS$SECRET_ALREADY_EXISTS": {
         "en": "Secret already exists",
         "ja": "シークレットは既に存在します",
diff --git a/frontend/src/routes/git-settings.tsx b/frontend/src/routes/git-settings.tsx
index e4a8a6f2310e..ce10009de0ed 100644
--- a/frontend/src/routes/git-settings.tsx
+++ b/frontend/src/routes/git-settings.tsx
@@ -7,6 +7,7 @@ import { useLogout } from "#/hooks/mutation/use-logout";
 import { GitHubTokenInput } from "#/components/features/settings/git-settings/github-token-input";
 import { GitLabTokenInput } from "#/components/features/settings/git-settings/gitlab-token-input";
 import { BitbucketTokenInput } from "#/components/features/settings/git-settings/bitbucket-token-input";
+import { GiteaTokenInput } from "#/components/features/settings/git-settings/gitea-token-input";
 import { ConfigureGitHubRepositoriesAnchor } from "#/components/features/settings/git-settings/configure-github-repositories-anchor";
 import { InstallSlackAppAnchor } from "#/components/features/settings/git-settings/install-slack-app-anchor";
 import { I18nKey } from "#/i18n/declaration";
@@ -37,6 +38,8 @@ function GitSettingsScreen() {
     React.useState(false);
   const [bitbucketTokenInputHasValue, setBitbucketTokenInputHasValue] =
     React.useState(false);
+  const [giteaTokenInputHasValue, setGiteaTokenInputHasValue] =
+    React.useState(false);
 
   const [githubHostInputHasValue, setGithubHostInputHasValue] =
     React.useState(false);
@@ -44,15 +47,19 @@ function GitSettingsScreen() {
     React.useState(false);
   const [bitbucketHostInputHasValue, setBitbucketHostInputHasValue] =
     React.useState(false);
+  const [giteaHostInputHasValue, setGiteaHostInputHasValue] =
+    React.useState(false);
 
   const existingGithubHost = settings?.PROVIDER_TOKENS_SET.github;
   const existingGitlabHost = settings?.PROVIDER_TOKENS_SET.gitlab;
   const existingBitbucketHost = settings?.PROVIDER_TOKENS_SET.bitbucket;
+  const existingGiteaHost = settings?.PROVIDER_TOKENS_SET.gitea;
 
   const isSaas = config?.APP_MODE === "saas";
   const isGitHubTokenSet = providers.includes("github");
   const isGitLabTokenSet = providers.includes("gitlab");
   const isBitbucketTokenSet = providers.includes("bitbucket");
+  const isGiteaTokenSet = providers.includes("gitea");
 
   const formAction = async (formData: FormData) => {
     const disconnectButtonClicked =
@@ -67,16 +74,19 @@ function GitSettingsScreen() {
     const gitlabToken = formData.get("gitlab-token-input")?.toString() || "";
     const bitbucketToken =
       formData.get("bitbucket-token-input")?.toString() || "";
+    const giteaToken = formData.get("gitea-token-input")?.toString() || "";
     const githubHost = formData.get("github-host-input")?.toString() || "";
     const gitlabHost = formData.get("gitlab-host-input")?.toString() || "";
     const bitbucketHost =
       formData.get("bitbucket-host-input")?.toString() || "";
+    const giteaHost = formData.get("gitea-host-input")?.toString() || "";
 
     // Create providers object with all tokens
     const providerTokens: Record<string, { token: string; host: string }> = {
       github: { token: githubToken, host: githubHost },
       gitlab: { token: gitlabToken, host: gitlabHost },
       bitbucket: { token: bitbucketToken, host: bitbucketHost },
+      gitea: { token: giteaToken, host: giteaHost },
     };
 
     saveGitProviders(
@@ -95,9 +105,11 @@ function GitSettingsScreen() {
           setGithubTokenInputHasValue(false);
           setGitlabTokenInputHasValue(false);
           setBitbucketTokenInputHasValue(false);
+          setGiteaTokenInputHasValue(false);
           setGithubHostInputHasValue(false);
           setGitlabHostInputHasValue(false);
           setBitbucketHostInputHasValue(false);
+          setGiteaHostInputHasValue(false);
         },
       },
     );
@@ -107,9 +119,11 @@ function GitSettingsScreen() {
     !githubTokenInputHasValue &&
     !gitlabTokenInputHasValue &&
     !bitbucketTokenInputHasValue &&
+    !giteaTokenInputHasValue &&
     !githubHostInputHasValue &&
     !gitlabHostInputHasValue &&
-    !bitbucketHostInputHasValue;
+    !bitbucketHostInputHasValue &&
+    !giteaHostInputHasValue;
   const shouldRenderExternalConfigureButtons = isSaas && config.APP_SLUG;
   const shouldRenderProjectManagementIntegrations =
     config?.FEATURE_FLAGS?.ENABLE_JIRA ||
@@ -196,6 +210,20 @@ function GitSettingsScreen() {
                 bitbucketHostSet={existingBitbucketHost}
               />
             )}
+
+            {!isSaas && (
+              <GiteaTokenInput
+                name="gitea-token-input"
+                isGiteaTokenSet={isGiteaTokenSet}
+                onChange={(value) => {
+                  setGiteaTokenInputHasValue(!!value);
+                }}
+                onGiteaHostChange={(value) => {
+                  setGiteaHostInputHasValue(!!value);
+                }}
+                giteaHostSet={existingGiteaHost}
+              />
+            )}
           </div>
         </div>
       )}
@@ -211,7 +239,7 @@ function GitSettingsScreen() {
               type="submit"
               variant="secondary"
               isDisabled={
-                !isGitHubTokenSet && !isGitLabTokenSet && !isBitbucketTokenSet
+                !isGitHubTokenSet && !isGitLabTokenSet && !isBitbucketTokenSet && !isGiteaTokenSet
               }
             >
               {t(I18nKey.GIT$DISCONNECT_TOKENS)}
diff --git a/frontend/src/routes/settings.tsx b/frontend/src/routes/settings.tsx
index 7ca2bd723e79..6d924741567a 100644
--- a/frontend/src/routes/settings.tsx
+++ b/frontend/src/routes/settings.tsx
@@ -4,7 +4,6 @@ import SettingsIcon from "#/icons/settings.svg?react";
 import { cn } from "#/utils/utils";
 import { useConfig } from "#/hooks/query/use-config";
 import { I18nKey } from "#/i18n/declaration";
-import { Route } from "./+types/settings";
 import OpenHands from "#/api/open-hands";
 import { queryClient } from "#/query-client-config";
 import { GetConfigResponse } from "#/api/open-hands.types";
@@ -33,7 +32,7 @@ const OSS_NAV_ITEMS = [
   { to: "/settings/secrets", text: "SETTINGS$NAV_SECRETS" },
 ];
 
-export const clientLoader = async ({ request }: Route.ClientLoaderArgs) => {
+export const clientLoader = async ({ request }: { request: Request }) => {
   const url = new URL(request.url);
   const { pathname } = url;
 
diff --git a/frontend/src/types/settings.ts b/frontend/src/types/settings.ts
index 9ee628ea5725..76e3a78a94c3 100644
--- a/frontend/src/types/settings.ts
+++ b/frontend/src/types/settings.ts
@@ -2,6 +2,7 @@ export const ProviderOptions = {
   github: "github",
   gitlab: "gitlab",
   bitbucket: "bitbucket",
+  gitea: "gitea",
   enterprise_sso: "enterprise_sso",
 } as const;
 
diff --git a/microagents/gitea.md b/microagents/gitea.md
new file mode 100644
index 000000000000..9985ff505ad4
--- /dev/null
+++ b/microagents/gitea.md
@@ -0,0 +1,84 @@
+---
+triggers:
+- gitea
+- gitea api
+- gitea integration
+- gitea repository
+- gitea pull request
+- gitea issue
+- gitea actions
+---
+
+# Gitea Integration Microagent
+
+You are an expert in Gitea integration and API usage. You help users work with Gitea repositories, issues, pull requests, and other Gitea-specific features.
+
+## Gitea API Knowledge
+
+### Authentication
+- Gitea uses token-based authentication
+- Tokens are passed in the `Authorization: token <TOKEN>` header
+- API base URL is typically `https://your-gitea-instance.com/api/v1`
+
+### Key API Endpoints
+- **User info**: `GET /user`
+- **Repositories**: `GET /user/repos` or `GET /repos/search`
+- **Issues**: `GET /repos/{owner}/{repo}/issues`
+- **Pull Requests**: `GET /repos/{owner}/{repo}/pulls`
+- **Branches**: `GET /repos/{owner}/{repo}/branches`
+- **Contents**: `GET /repos/{owner}/{repo}/contents/{path}`
+
+### Repository Operations
+- Clone repositories using HTTPS with token authentication
+- Create branches and pull requests
+- Manage issues and labels
+- Access repository contents and metadata
+
+## Best Practices
+
+### Working with Gitea
+1. **Self-hosted instances**: Always verify the correct base URL for the Gitea instance
+2. **Token permissions**: Ensure tokens have appropriate scopes for the required operations
+3. **API rate limits**: Be mindful of rate limits on self-hosted instances
+4. **Version compatibility**: Check Gitea version for API feature availability
+
+### Integration Tips
+1. Use the Gitea API v1 which is largely compatible with GitHub API v3
+2. Handle authentication errors gracefully
+3. Support both gitea.com and self-hosted instances
+4. Implement proper error handling for network issues
+
+## Common Tasks
+
+### Repository Management
+- List user repositories
+- Search for repositories
+- Get repository details and metadata
+- Access repository contents
+
+### Issue and PR Management
+- Create and manage issues
+- Create and review pull requests
+- Handle merge conflicts
+- Manage labels and milestones
+
+### CI/CD Integration
+- Work with Gitea Actions (if available)
+- Integrate with external CI/CD systems
+- Handle webhooks and notifications
+
+## Troubleshooting
+
+### Common Issues
+1. **Authentication failures**: Check token validity and permissions
+2. **API endpoint not found**: Verify Gitea version and API availability
+3. **Network connectivity**: Handle timeouts and connection errors
+4. **Self-hosted configuration**: Verify instance URL and SSL settings
+
+### Debugging Tips
+- Use API documentation specific to the Gitea version
+- Test API calls with curl or similar tools
+- Check Gitea instance logs for server-side issues
+- Verify token scopes and permissions
+
+Remember to always respect the Gitea instance's terms of service and API usage guidelines.
diff --git a/openhands/integrations/gitea/__init__.py b/openhands/integrations/gitea/__init__.py
new file mode 100644
index 000000000000..e69de29bb2d1
diff --git a/openhands/integrations/gitea/gitea_service.py b/openhands/integrations/gitea/gitea_service.py
new file mode 100644
index 000000000000..1b1a05b3c4d7
--- /dev/null
+++ b/openhands/integrations/gitea/gitea_service.py
@@ -0,0 +1,341 @@
+import base64
+from typing import Any
+
+import httpx
+from pydantic import SecretStr
+
+from openhands.core.logger import openhands_logger as logger
+from openhands.integrations.service_types import (
+    BaseGitService,
+    Branch,
+    GitService,
+    OwnerType,
+    ProviderType,
+    Repository,
+    RequestMethod,
+    SuggestedTask,
+    TaskType,
+    User,
+)
+from openhands.microagent.types import MicroagentContentResponse
+from openhands.server.types import AppMode
+
+
+class GiteaService(BaseGitService, GitService):
+    """Implementation of GitService for Gitea integration.
+
+    This service provides integration with Gitea instances, supporting both
+    self-hosted and cloud-hosted Gitea installations. The API is largely
+    compatible with GitHub's API v3, with some differences in endpoints
+    and response formats.
+    """
+
+    BASE_URL = 'https://gitea.com/api/v1'  # Default for gitea.com
+    token: SecretStr = SecretStr('')
+    refresh = False
+
+    def __init__(
+        self,
+        user_id: str | None = None,
+        external_auth_id: str | None = None,
+        external_auth_token: SecretStr | None = None,
+        token: SecretStr | None = None,
+        external_token_manager: bool = False,
+        base_domain: str | None = None,
+    ):
+        self.user_id = user_id
+        self.external_token_manager = external_token_manager
+
+        if token:
+            self.token = token
+
+        if base_domain:
+            # Check if protocol is already included
+            if base_domain.startswith(('http://', 'https://')):
+                # Use the provided protocol
+                self.BASE_URL = f'{base_domain}/api/v1'
+            else:
+                # Default to https if no protocol specified
+                self.BASE_URL = f'https://{base_domain}/api/v1'
+
+        self.external_auth_id = external_auth_id
+        self.external_auth_token = external_auth_token
+
+    @property
+    def provider(self) -> str:
+        return ProviderType.GITEA.value
+
+    async def _get_gitea_headers(self) -> dict:
+        """Retrieve the Gitea Token to construct the headers."""
+        if not self.token:
+            latest_token = await self.get_latest_token()
+            if latest_token:
+                self.token = latest_token
+
+        return {
+            'Authorization': f'token {self.token.get_secret_value() if self.token else ""}',
+            'Accept': 'application/json',
+        }
+
+    def _has_token_expired(self, status_code: int) -> bool:
+        return status_code == 401
+
+    async def get_latest_token(self) -> SecretStr | None:
+        return self.token
+
+    async def _get_cursorrules_url(self, repository: str) -> str:
+        """Get the URL for checking .cursorrules file."""
+        return f'{self.BASE_URL}/repos/{repository}/contents/.cursorrules'
+
+    async def _get_microagents_directory_url(
+        self, repository: str, microagents_path: str
+    ) -> str:
+        """Get the URL for checking microagents directory."""
+        return f'{self.BASE_URL}/repos/{repository}/contents/{microagents_path}'
+
+    def _get_microagents_directory_params(self, microagents_path: str) -> dict | None:
+        """Get parameters for the microagents directory request."""
+        return None  # Gitea doesn't need additional parameters
+
+    def _is_valid_microagent_file(self, item: dict) -> bool:
+        """Check if an item represents a valid microagent file."""
+        return (
+            item.get('type') == 'file'
+            and item.get('name', '').endswith('.md')
+            and not item.get('name', '').startswith('.')
+        )
+
+    def _get_file_name_from_item(self, item: dict) -> str:
+        """Extract file name from directory item."""
+        return item.get('name', '')
+
+    def _get_file_path_from_item(self, item: dict, microagents_path: str) -> str:
+        """Extract file path from directory item."""
+        return item.get('path', '')
+
+    async def _make_request(
+        self,
+        url: str,
+        params: dict | None = None,
+        method: RequestMethod = RequestMethod.GET,
+    ) -> tuple[Any, dict]:
+        """Make an HTTP request to the Gitea API."""
+        headers = await self._get_gitea_headers()
+
+        async with httpx.AsyncClient() as client:
+            try:
+                response = await self.execute_request(
+                    client, url, headers, params, method
+                )
+                response.raise_for_status()
+
+                # Parse response headers for pagination info
+                response_headers = dict(response.headers)
+
+                # Handle different content types
+                if response.headers.get('content-type', '').startswith(
+                    'application/json'
+                ):
+                    return response.json(), response_headers
+                else:
+                    return response.text, response_headers
+
+            except httpx.HTTPStatusError as e:
+                raise self.handle_http_status_error(e)
+            except httpx.HTTPError as e:
+                raise self.handle_http_error(e)
+
+    async def verify_access(self) -> bool:
+        """Verify that the token has access to the Gitea API."""
+        try:
+            await self.get_user()
+            return True
+        except Exception:
+            return False
+
+    async def get_user(self) -> User:
+        """Get the authenticated user's information."""
+        url = f'{self.BASE_URL}/user'
+        response, _ = await self._make_request(url)
+
+        return User(
+            id=str(response['id']),
+            login=response['login'],
+            avatar_url=response['avatar_url'],
+            company=response.get('company'),
+            name=response.get('full_name'),
+            email=response.get('email'),
+        )
+
+    async def search_repositories(
+        self, query: str, per_page: int, sort: str, order: str, public: bool
+    ) -> list[Repository]:
+        """Search for repositories."""
+        url = f'{self.BASE_URL}/repos/search'
+        params = {
+            'q': query,
+            'limit': per_page,
+            'sort': sort,
+            'order': order,
+        }
+
+        if public:
+            params['private'] = 'false'
+
+        response, _ = await self._make_request(url, params)
+        repositories = []
+
+        for repo in response.get('data', []):
+            repositories.append(self._convert_to_repository(repo))
+
+        return repositories
+
+    async def get_all_repositories(
+        self, sort: str, app_mode: AppMode
+    ) -> list[Repository]:
+        """Get all repositories for the authenticated user."""
+        url = f'{self.BASE_URL}/user/repos'
+        params = {
+            'sort': sort,
+            'limit': 100,  # Gitea's max per page
+        }
+
+        response, _ = await self._make_request(url, params)
+        repositories = []
+
+        for repo in response:
+            repositories.append(self._convert_to_repository(repo))
+
+        return repositories
+
+    async def get_paginated_repos(
+        self,
+        page: int,
+        per_page: int,
+        sort: str,
+        installation_id: str | None,
+        query: str | None = None,
+    ) -> list[Repository]:
+        """Get a page of repositories."""
+        url = f'{self.BASE_URL}/user/repos'
+        params = {
+            'page': page,
+            'limit': per_page,
+            'sort': sort,
+        }
+
+        response, _ = await self._make_request(url, params)
+        repositories = []
+
+        for repo in response:
+            repositories.append(self._convert_to_repository(repo))
+
+        return repositories
+
+    async def get_suggested_tasks(self) -> list[SuggestedTask]:
+        """Get suggested tasks for the authenticated user."""
+        # Get user's repositories first
+        repositories = await self.get_all_repositories('updated', AppMode.SAAS)
+        tasks = []
+
+        # For each repository, check for open issues and PRs
+        for repo in repositories[:10]:  # Limit to first 10 repos for performance
+            try:
+                # Get open issues
+                issues_url = f'{self.BASE_URL}/repos/{repo.full_name}/issues'
+                issues_params = {'state': 'open', 'type': 'issues', 'limit': 5}
+                issues_response, _ = await self._make_request(issues_url, issues_params)
+
+                for issue in issues_response:
+                    tasks.append(
+                        SuggestedTask(
+                            git_provider=ProviderType.GITEA,
+                            task_type=TaskType.OPEN_ISSUE,
+                            repo=repo.full_name,
+                            issue_number=issue['number'],
+                            title=issue['title'],
+                        )
+                    )
+
+                # Get open PRs
+                prs_url = f'{self.BASE_URL}/repos/{repo.full_name}/pulls'
+                prs_params = {'state': 'open', 'limit': 5}
+                prs_response, _ = await self._make_request(prs_url, prs_params)
+
+                for pr in prs_response:
+                    tasks.append(
+                        SuggestedTask(
+                            git_provider=ProviderType.GITEA,
+                            task_type=TaskType.OPEN_PR,
+                            repo=repo.full_name,
+                            issue_number=pr['number'],
+                            title=pr['title'],
+                        )
+                    )
+
+            except Exception as e:
+                logger.warning(f'Error fetching tasks for {repo.full_name}: {e}')
+                continue
+
+        return tasks
+
+    async def get_repository_details_from_repo_name(
+        self, repository: str
+    ) -> Repository:
+        """Get repository details from repository name."""
+        url = f'{self.BASE_URL}/repos/{repository}'
+        response, _ = await self._make_request(url)
+        return self._convert_to_repository(response)
+
+    async def get_branches(self, repository: str) -> list[Branch]:
+        """Get branches for a repository."""
+        url = f'{self.BASE_URL}/repos/{repository}/branches'
+        response, _ = await self._make_request(url)
+
+        branches = []
+        for branch in response:
+            branches.append(
+                Branch(
+                    name=branch['name'],
+                    commit_sha=branch['commit']['id'],
+                    protected=branch.get('protected', False),
+                    last_push_date=branch['commit'].get('timestamp'),
+                )
+            )
+
+        return branches
+
+    async def get_microagent_content(
+        self, repository: str, file_path: str
+    ) -> MicroagentContentResponse:
+        """Get content of a specific microagent file."""
+        url = f'{self.BASE_URL}/repos/{repository}/contents/{file_path}'
+        response, _ = await self._make_request(url)
+
+        # Decode base64 content
+        content = base64.b64decode(response['content']).decode('utf-8')
+
+        # Parse the microagent content
+        return self._parse_microagent_content(content, file_path)
+
+    def _convert_to_repository(self, repo_data: dict) -> Repository:
+        """Convert Gitea repository data to Repository object."""
+        return Repository(
+            id=str(repo_data['id']),
+            full_name=repo_data['full_name'],
+            git_provider=ProviderType.GITEA,
+            is_public=not repo_data.get('private', False),
+            stargazers_count=repo_data.get('stars_count', 0),
+            pushed_at=repo_data.get('updated_at'),
+            owner_type=OwnerType.ORGANIZATION
+            if repo_data.get('owner', {}).get('type') == 'Organization'
+            else OwnerType.USER,
+            main_branch=repo_data.get('default_branch', 'main'),
+        )
+
+
+# Create the implementation class that will be used by the provider handler
+class GiteaServiceImpl(GiteaService):
+    """Implementation class for Gitea service."""
+
+    pass
diff --git a/openhands/integrations/provider.py b/openhands/integrations/provider.py
index 51e74d300d7d..5235a823d8f8 100644
--- a/openhands/integrations/provider.py
+++ b/openhands/integrations/provider.py
@@ -16,6 +16,7 @@
 from openhands.events.action.commands import CmdRunAction
 from openhands.events.stream import EventStream
 from openhands.integrations.bitbucket.bitbucket_service import BitBucketServiceImpl
+from openhands.integrations.gitea.gitea_service import GiteaServiceImpl
 from openhands.integrations.github.github_service import GithubServiceImpl
 from openhands.integrations.gitlab.gitlab_service import GitLabServiceImpl
 from openhands.integrations.service_types import (
@@ -104,6 +105,7 @@ class ProviderHandler:
         ProviderType.GITHUB: 'github.com',
         ProviderType.GITLAB: 'gitlab.com',
         ProviderType.BITBUCKET: 'bitbucket.org',
+        ProviderType.GITEA: 'gitea.com',
     }
 
     def __init__(
@@ -122,6 +124,7 @@ def __init__(
             ProviderType.GITHUB: GithubServiceImpl,
             ProviderType.GITLAB: GitLabServiceImpl,
             ProviderType.BITBUCKET: BitBucketServiceImpl,
+            ProviderType.GITEA: GiteaServiceImpl,
         }
 
         self.external_auth_id = external_auth_id
@@ -631,8 +634,11 @@ async def get_authenticated_git_url(self, repo_name: str) -> str:
                     else:
                         # Access token format: use x-token-auth
                         remote_url = f'https://x-token-auth:{token_value}@{domain}/{repo_name}.git'
+                elif provider == ProviderType.GITEA:
+                    # Gitea uses token authentication similar to GitHub
+                    remote_url = f'https://{token_value}@{domain}/{repo_name}.git'
                 else:
-                    # GitHub
+                    # GitHub and others
                     remote_url = f'https://{token_value}@{domain}/{repo_name}.git'
             else:
                 remote_url = f'https://{domain}/{repo_name}.git'
diff --git a/openhands/integrations/service_types.py b/openhands/integrations/service_types.py
index 55d43fdd96c3..728b26f66960 100644
--- a/openhands/integrations/service_types.py
+++ b/openhands/integrations/service_types.py
@@ -18,6 +18,7 @@ class ProviderType(Enum):
     GITHUB = 'github'
     GITLAB = 'gitlab'
     BITBUCKET = 'bitbucket'
+    GITEA = 'gitea'
     ENTERPRISE_SSO = 'enterprise_sso'
 
 
@@ -73,6 +74,16 @@ def get_provider_terms(self) -> dict:
                 'ciProvider': 'Bitbucket',
                 'requestVerb': 'pull request',
             }
+        elif self.git_provider == ProviderType.GITEA:
+            return {
+                'requestType': 'Pull Request',
+                'requestTypeShort': 'PR',
+                'apiName': 'Gitea API',
+                'tokenEnvVar': 'GITEA_TOKEN',
+                'ciSystem': 'Gitea Actions',
+                'ciProvider': 'Gitea',
+                'requestVerb': 'pull request',
+            }
 
         raise ValueError(f'Provider {self.git_provider} for suggested task prompts')
 
diff --git a/openhands/integrations/utils.py b/openhands/integrations/utils.py
index 9b8c1d430f8c..067a0c79663d 100644
--- a/openhands/integrations/utils.py
+++ b/openhands/integrations/utils.py
@@ -2,6 +2,7 @@
 
 from openhands.core.logger import openhands_logger as logger
 from openhands.integrations.bitbucket.bitbucket_service import BitBucketService
+from openhands.integrations.gitea.gitea_service import GiteaService
 from openhands.integrations.github.github_service import GitHubService
 from openhands.integrations.gitlab.gitlab_service import GitLabService
 from openhands.integrations.provider import ProviderType
@@ -11,7 +12,7 @@ async def validate_provider_token(
     token: SecretStr, base_domain: str | None = None
 ) -> ProviderType | None:
     """
-    Determine whether a token is for GitHub, GitLab, or Bitbucket by attempting to get user info
+    Determine whether a token is for GitHub, GitLab, Bitbucket, or Gitea by attempting to get user info
     from the services.
 
     Args:
@@ -22,6 +23,7 @@ async def validate_provider_token(
         'github' if it's a GitHub token
         'gitlab' if it's a GitLab token
         'bitbucket' if it's a Bitbucket token
+        'gitea' if it's a Gitea token
         None if the token is invalid for all services
     """
     # Skip validation for empty tokens
@@ -46,7 +48,7 @@ async def validate_provider_token(
     except Exception as e:
         gitlab_error = e
 
-    # Try Bitbucket last
+    # Try Bitbucket next
     bitbucket_error = None
     try:
         bitbucket_service = BitBucketService(token=token, base_domain=base_domain)
@@ -55,8 +57,17 @@ async def validate_provider_token(
     except Exception as e:
         bitbucket_error = e
 
+    # Try Gitea last
+    gitea_error = None
+    try:
+        gitea_service = GiteaService(token=token, base_domain=base_domain)
+        await gitea_service.get_user()
+        return ProviderType.GITEA
+    except Exception as e:
+        gitea_error = e
+
     logger.debug(
-        f'Failed to validate token: {github_error} \n {gitlab_error} \n {bitbucket_error}'
+        f'Failed to validate token: {github_error} \n {gitlab_error} \n {bitbucket_error} \n {gitea_error}'
     )
 
     return None

From c924505bf5e867101eec24bee22c183007eb5161 Mon Sep 17 00:00:00 2001
From: openhands <openhands@all-hands.dev>
Date: Wed, 13 Aug 2025 07:56:04 +0000
Subject: [PATCH 2/3] Improve Gitea integration API compatibility and error
 handling

- Fix repository search parameter: use is_private instead of private
- Add robust response structure handling for both array and object responses
- Implement proper pagination limits (max 100 for Gitea)
- Enhance headers with User-Agent and improved structure
- Add better validation for required fields in API responses
- Improve branch commit data access with safe fallbacks
- Add comprehensive error handling for suggested tasks

All changes verified against latest Gitea API specification.
---
 openhands/integrations/gitea/gitea_service.py | 85 +++++++++++++------
 1 file changed, 59 insertions(+), 26 deletions(-)

diff --git a/openhands/integrations/gitea/gitea_service.py b/openhands/integrations/gitea/gitea_service.py
index 1b1a05b3c4d7..097ba9fc2e43 100644
--- a/openhands/integrations/gitea/gitea_service.py
+++ b/openhands/integrations/gitea/gitea_service.py
@@ -72,11 +72,18 @@ async def _get_gitea_headers(self) -> dict:
             if latest_token:
                 self.token = latest_token
 
-        return {
-            'Authorization': f'token {self.token.get_secret_value() if self.token else ""}',
+        headers = {
             'Accept': 'application/json',
+            'Content-Type': 'application/json',
+            'User-Agent': 'OpenHands-Gitea-Integration/1.0',
         }
 
+        if self.token:
+            # Gitea supports both 'token' and 'Bearer' authorization
+            headers['Authorization'] = f'token {self.token.get_secret_value()}'
+
+        return headers
+
     def _has_token_expired(self, status_code: int) -> bool:
         return status_code == 401
 
@@ -179,12 +186,14 @@ async def search_repositories(
             'order': order,
         }
 
+        # Use is_private parameter instead of private for public repositories
         if public:
-            params['private'] = 'false'
+            params['is_private'] = False
 
         response, _ = await self._make_request(url, params)
         repositories = []
 
+        # The response structure has 'data' array containing repositories
         for repo in response.get('data', []):
             repositories.append(self._convert_to_repository(repo))
 
@@ -203,7 +212,10 @@ async def get_all_repositories(
         response, _ = await self._make_request(url, params)
         repositories = []
 
-        for repo in response:
+        # Handle both array response and object with data array
+        repo_list = response if isinstance(response, list) else response.get('data', [])
+
+        for repo in repo_list:
             repositories.append(self._convert_to_repository(repo))
 
         return repositories
@@ -220,14 +232,17 @@ async def get_paginated_repos(
         url = f'{self.BASE_URL}/user/repos'
         params = {
             'page': page,
-            'limit': per_page,
+            'limit': min(per_page, 100),  # Gitea max limit is 100
             'sort': sort,
         }
 
         response, _ = await self._make_request(url, params)
         repositories = []
 
-        for repo in response:
+        # Handle both array response and object with data array
+        repo_list = response if isinstance(response, list) else response.get('data', [])
+
+        for repo in repo_list:
             repositories.append(self._convert_to_repository(repo))
 
         return repositories
@@ -246,32 +261,48 @@ async def get_suggested_tasks(self) -> list[SuggestedTask]:
                 issues_params = {'state': 'open', 'type': 'issues', 'limit': 5}
                 issues_response, _ = await self._make_request(issues_url, issues_params)
 
-                for issue in issues_response:
-                    tasks.append(
-                        SuggestedTask(
-                            git_provider=ProviderType.GITEA,
-                            task_type=TaskType.OPEN_ISSUE,
-                            repo=repo.full_name,
-                            issue_number=issue['number'],
-                            title=issue['title'],
+                # Handle both array response and object with data array
+                issues_list = (
+                    issues_response
+                    if isinstance(issues_response, list)
+                    else issues_response.get('data', [])
+                )
+
+                for issue in issues_list:
+                    if issue.get('number') and issue.get('title'):
+                        tasks.append(
+                            SuggestedTask(
+                                git_provider=ProviderType.GITEA,
+                                task_type=TaskType.OPEN_ISSUE,
+                                repo=repo.full_name,
+                                issue_number=issue['number'],
+                                title=issue['title'],
+                            )
                         )
-                    )
 
                 # Get open PRs
                 prs_url = f'{self.BASE_URL}/repos/{repo.full_name}/pulls'
                 prs_params = {'state': 'open', 'limit': 5}
                 prs_response, _ = await self._make_request(prs_url, prs_params)
 
-                for pr in prs_response:
-                    tasks.append(
-                        SuggestedTask(
-                            git_provider=ProviderType.GITEA,
-                            task_type=TaskType.OPEN_PR,
-                            repo=repo.full_name,
-                            issue_number=pr['number'],
-                            title=pr['title'],
+                # Handle both array response and object with data array
+                prs_list = (
+                    prs_response
+                    if isinstance(prs_response, list)
+                    else prs_response.get('data', [])
+                )
+
+                for pr in prs_list:
+                    if pr.get('number') and pr.get('title'):
+                        tasks.append(
+                            SuggestedTask(
+                                git_provider=ProviderType.GITEA,
+                                task_type=TaskType.OPEN_PR,
+                                repo=repo.full_name,
+                                issue_number=pr['number'],
+                                title=pr['title'],
+                            )
                         )
-                    )
 
             except Exception as e:
                 logger.warning(f'Error fetching tasks for {repo.full_name}: {e}')
@@ -294,12 +325,14 @@ async def get_branches(self, repository: str) -> list[Branch]:
 
         branches = []
         for branch in response:
+            # Extract commit information safely
+            commit = branch.get('commit', {})
             branches.append(
                 Branch(
                     name=branch['name'],
-                    commit_sha=branch['commit']['id'],
+                    commit_sha=commit.get('id', ''),
                     protected=branch.get('protected', False),
-                    last_push_date=branch['commit'].get('timestamp'),
+                    last_push_date=commit.get('timestamp'),
                 )
             )
 

From 276a1fb9549e95c9e442bc93f3658e8cb3e44654 Mon Sep 17 00:00:00 2001
From: openhands <openhands@all-hands.dev>
Date: Wed, 13 Aug 2025 08:50:27 +0000
Subject: [PATCH 3/3] Add comprehensive test suite for Gitea integration

- Create test_gitea_service.py with 17 test cases covering all major functionality
- Test service initialization, authentication, API requests, and data conversion
- Include error handling tests for network failures and invalid responses
- Test pagination limits and response format handling
- Ensure compatibility with existing GitHub service tests
- All tests pass successfully

Co-authored-by: openhands <openhands@all-hands.dev>
---
 tests/unit/test_gitea_service.py | 587 +++++++++++++++++++++++++++++++
 1 file changed, 587 insertions(+)
 create mode 100644 tests/unit/test_gitea_service.py

diff --git a/tests/unit/test_gitea_service.py b/tests/unit/test_gitea_service.py
new file mode 100644
index 000000000000..c1d1dc313d92
--- /dev/null
+++ b/tests/unit/test_gitea_service.py
@@ -0,0 +1,587 @@
+"""Tests for Gitea integration."""
+
+from unittest.mock import AsyncMock, Mock, patch
+
+import httpx
+import pytest
+from pydantic import SecretStr
+
+from openhands.integrations.gitea.gitea_service import GiteaService
+from openhands.integrations.service_types import (
+    AuthenticationError,
+    Branch,
+    OwnerType,
+    ProviderType,
+    Repository,
+    TaskType,
+    User,
+)
+from openhands.server.types import AppMode
+
+
+@pytest.mark.asyncio
+async def test_gitea_service_initialization():
+    """Test Gitea service initialization with different configurations."""
+    # Test initialization with SecretStr token
+    token = SecretStr('test-token')
+    service = GiteaService(user_id=None, token=token)
+    assert service.token == token
+    assert service.token.get_secret_value() == 'test-token'
+    assert service.BASE_URL == 'https://gitea.com/api/v1'
+
+    # Test initialization with custom base domain
+    service = GiteaService(
+        user_id=None, token=token, base_domain='my-gitea.example.com'
+    )
+    assert service.BASE_URL == 'https://my-gitea.example.com/api/v1'
+
+    # Test initialization with protocol in base domain
+    service = GiteaService(
+        user_id=None, token=token, base_domain='http://localhost:3000'
+    )
+    assert service.BASE_URL == 'http://localhost:3000/api/v1'
+
+    # Test initialization without token
+    service = GiteaService(user_id='test-user')
+    assert service.token == SecretStr('')
+
+
+@pytest.mark.asyncio
+async def test_gitea_service_headers():
+    """Test Gitea service header generation."""
+    token = SecretStr('test-token')
+    service = GiteaService(user_id=None, token=token)
+
+    headers = await service._get_gitea_headers()
+    assert headers['Authorization'] == 'token test-token'
+    assert headers['Accept'] == 'application/json'
+    assert headers['Content-Type'] == 'application/json'
+    assert headers['User-Agent'] == 'OpenHands-Gitea-Integration/1.0'
+
+    # Test headers without token
+    service = GiteaService(user_id='test-user')
+    headers = await service._get_gitea_headers()
+    assert 'Authorization' not in headers
+    assert headers['Accept'] == 'application/json'
+
+
+@pytest.mark.asyncio
+async def test_gitea_service_token_expiry():
+    """Test token expiry detection."""
+    service = GiteaService(user_id=None, token=SecretStr('test-token'))
+
+    assert service._has_token_expired(401)
+    assert not service._has_token_expired(200)
+    assert not service._has_token_expired(404)
+    assert not service._has_token_expired(500)
+
+
+@pytest.mark.asyncio
+async def test_gitea_service_make_request():
+    """Test the _make_request method with mocked HTTP client."""
+    mock_response = Mock()
+    mock_response.status_code = 200
+    mock_response.json.return_value = {'login': 'test-user'}
+    mock_response.headers = {'content-type': 'application/json'}
+    mock_response.raise_for_status = Mock()
+
+    mock_client = AsyncMock()
+    mock_client.get.return_value = mock_response
+    mock_client.__aenter__.return_value = mock_client
+    mock_client.__aexit__.return_value = None
+
+    with patch('httpx.AsyncClient', return_value=mock_client):
+        service = GiteaService(user_id=None, token=SecretStr('test-token'))
+        response, headers = await service._make_request('https://gitea.com/api/v1/user')
+
+        assert response == {'login': 'test-user'}
+        mock_client.get.assert_called_once()
+
+        # Test error handling with 401 status code
+        mock_response.status_code = 401
+        mock_response.raise_for_status.side_effect = httpx.HTTPStatusError(
+            message='401 Unauthorized', request=Mock(), response=mock_response
+        )
+
+        mock_client.get.reset_mock()
+        mock_client.get.return_value = mock_response
+
+        with pytest.raises(AuthenticationError):
+            await service._make_request('https://gitea.com/api/v1/user')
+
+
+@pytest.mark.asyncio
+async def test_gitea_get_user():
+    """Test getting user information."""
+    service = GiteaService(user_id=None, token=SecretStr('test-token'))
+
+    mock_user_data = {
+        'id': 123,
+        'login': 'test-user',
+        'avatar_url': 'https://example.com/avatar.png',
+        'company': 'Test Company',
+        'full_name': 'Test User',
+        'email': 'test@example.com',
+    }
+
+    with patch.object(service, '_make_request', return_value=(mock_user_data, {})):
+        user = await service.get_user()
+
+        assert isinstance(user, User)
+        assert user.id == '123'
+        assert user.login == 'test-user'
+        assert user.avatar_url == 'https://example.com/avatar.png'
+        assert user.company == 'Test Company'
+        assert user.name == 'Test User'
+        assert user.email == 'test@example.com'
+
+
+@pytest.mark.asyncio
+async def test_gitea_search_repositories():
+    """Test repository search functionality."""
+    service = GiteaService(user_id=None, token=SecretStr('test-token'))
+
+    mock_search_response = {
+        'data': [
+            {
+                'id': 123,
+                'full_name': 'test-user/test-repo',
+                'private': False,
+                'stars_count': 10,
+                'updated_at': '2023-01-01T00:00:00Z',
+                'owner': {'type': 'User'},
+                'default_branch': 'main',
+            }
+        ]
+    }
+
+    with patch.object(
+        service, '_make_request', return_value=(mock_search_response, {})
+    ):
+        repositories = await service.search_repositories(
+            query='test', per_page=10, sort='stars', order='desc', public=True
+        )
+
+        assert len(repositories) == 1
+        repo = repositories[0]
+        assert isinstance(repo, Repository)
+        assert repo.id == '123'
+        assert repo.full_name == 'test-user/test-repo'
+        assert repo.git_provider == ProviderType.GITEA
+        assert repo.is_public is True
+        assert repo.stargazers_count == 10
+        assert repo.owner_type == OwnerType.USER
+
+
+@pytest.mark.asyncio
+async def test_gitea_get_all_repositories_user_type():
+    """Test getting all repositories with user owner type."""
+    service = GiteaService(user_id=None, token=SecretStr('test-token'))
+
+    mock_repos = [
+        {
+            'id': 123,
+            'full_name': 'test-user/user-repo',
+            'private': False,
+            'stars_count': 10,
+            'updated_at': '2023-01-01T00:00:00Z',
+            'owner': {'type': 'User'},
+            'default_branch': 'main',
+        },
+        {
+            'id': 456,
+            'full_name': 'test-user/another-repo',
+            'private': True,
+            'stars_count': 5,
+            'updated_at': '2023-01-02T00:00:00Z',
+            'owner': {'type': 'User'},
+            'default_branch': 'master',
+        },
+    ]
+
+    with patch.object(service, '_make_request', return_value=(mock_repos, {})):
+        repositories = await service.get_all_repositories('updated', AppMode.SAAS)
+
+        assert len(repositories) == 2
+        for repo in repositories:
+            assert repo.owner_type == OwnerType.USER
+            assert isinstance(repo, Repository)
+            assert repo.git_provider == ProviderType.GITEA
+
+
+@pytest.mark.asyncio
+async def test_gitea_get_all_repositories_organization_type():
+    """Test getting all repositories with organization owner type."""
+    service = GiteaService(user_id=None, token=SecretStr('test-token'))
+
+    mock_repos = [
+        {
+            'id': 789,
+            'full_name': 'test-org/org-repo',
+            'private': False,
+            'stars_count': 25,
+            'updated_at': '2023-01-01T00:00:00Z',
+            'owner': {'type': 'Organization'},
+            'default_branch': 'main',
+        }
+    ]
+
+    with patch.object(service, '_make_request', return_value=(mock_repos, {})):
+        repositories = await service.get_all_repositories('updated', AppMode.SAAS)
+
+        assert len(repositories) == 1
+        repo = repositories[0]
+        assert repo.owner_type == OwnerType.ORGANIZATION
+        assert isinstance(repo, Repository)
+        assert repo.git_provider == ProviderType.GITEA
+
+
+@pytest.mark.asyncio
+async def test_gitea_get_paginated_repos():
+    """Test paginated repository retrieval."""
+    service = GiteaService(user_id=None, token=SecretStr('test-token'))
+
+    mock_repos = [
+        {
+            'id': 123,
+            'full_name': 'test-user/repo1',
+            'private': False,
+            'stars_count': 10,
+            'updated_at': '2023-01-01T00:00:00Z',
+            'owner': {'type': 'User'},
+            'default_branch': 'main',
+        }
+    ]
+
+    with patch.object(service, '_make_request', return_value=(mock_repos, {})):
+        repositories = await service.get_paginated_repos(
+            page=1, per_page=50, sort='updated', installation_id=None
+        )
+
+        assert len(repositories) == 1
+        assert repositories[0].full_name == 'test-user/repo1'
+
+
+@pytest.mark.asyncio
+async def test_gitea_get_suggested_tasks():
+    """Test getting suggested tasks from issues and PRs."""
+    service = GiteaService(user_id=None, token=SecretStr('test-token'))
+
+    # Mock repositories
+
+    # Mock issues
+    mock_issues = [
+        {'number': 1, 'title': 'Fix bug in authentication'},
+        {'number': 2, 'title': 'Add new feature'},
+    ]
+
+    # Mock PRs
+    mock_prs = [
+        {'number': 3, 'title': 'Update documentation'},
+    ]
+
+    with patch.object(
+        service,
+        'get_all_repositories',
+        return_value=[
+            Repository(
+                id='123',
+                full_name='test-user/test-repo',
+                git_provider=ProviderType.GITEA,
+                is_public=True,
+                stargazers_count=10,
+                owner_type=OwnerType.USER,
+                main_branch='main',
+            )
+        ],
+    ):
+        with patch.object(service, '_make_request') as mock_request:
+            # First call for issues, second call for PRs
+            mock_request.side_effect = [
+                (mock_issues, {}),
+                (mock_prs, {}),
+            ]
+
+            tasks = await service.get_suggested_tasks()
+
+            assert len(tasks) == 3
+
+            # Check issue tasks
+            issue_tasks = [t for t in tasks if t.task_type == TaskType.OPEN_ISSUE]
+            assert len(issue_tasks) == 2
+            assert issue_tasks[0].issue_number == 1
+            assert issue_tasks[0].title == 'Fix bug in authentication'
+            assert issue_tasks[0].git_provider == ProviderType.GITEA
+
+            # Check PR tasks
+            pr_tasks = [t for t in tasks if t.task_type == TaskType.OPEN_PR]
+            assert len(pr_tasks) == 1
+            assert pr_tasks[0].issue_number == 3
+            assert pr_tasks[0].title == 'Update documentation'
+
+
+@pytest.mark.asyncio
+async def test_gitea_get_repository_details():
+    """Test getting repository details."""
+    service = GiteaService(user_id=None, token=SecretStr('test-token'))
+
+    mock_repo_data = {
+        'id': 123,
+        'full_name': 'test-user/test-repo',
+        'private': False,
+        'stars_count': 10,
+        'updated_at': '2023-01-01T00:00:00Z',
+        'owner': {'type': 'User'},
+        'default_branch': 'main',
+    }
+
+    with patch.object(service, '_make_request', return_value=(mock_repo_data, {})):
+        repository = await service.get_repository_details_from_repo_name(
+            'test-user/test-repo'
+        )
+
+        assert isinstance(repository, Repository)
+        assert repository.id == '123'
+        assert repository.full_name == 'test-user/test-repo'
+        assert repository.git_provider == ProviderType.GITEA
+
+
+@pytest.mark.asyncio
+async def test_gitea_get_branches():
+    """Test getting repository branches."""
+    service = GiteaService(user_id=None, token=SecretStr('test-token'))
+
+    mock_branches = [
+        {
+            'name': 'main',
+            'protected': False,
+            'commit': {
+                'id': 'abc123',
+                'timestamp': '2023-01-01T00:00:00Z',
+            },
+        },
+        {
+            'name': 'develop',
+            'protected': True,
+            'commit': {
+                'id': 'def456',
+                'timestamp': '2023-01-02T00:00:00Z',
+            },
+        },
+        {
+            'name': 'feature-branch',
+            'protected': False,
+            'commit': {},  # Test empty commit object
+        },
+    ]
+
+    with patch.object(service, '_make_request', return_value=(mock_branches, {})):
+        branches = await service.get_branches('test-user/test-repo')
+
+        assert len(branches) == 3
+
+        main_branch = branches[0]
+        assert isinstance(main_branch, Branch)
+        assert main_branch.name == 'main'
+        assert main_branch.commit_sha == 'abc123'
+        assert main_branch.protected is False
+        assert main_branch.last_push_date == '2023-01-01T00:00:00Z'
+
+        develop_branch = branches[1]
+        assert develop_branch.name == 'develop'
+        assert develop_branch.protected is True
+
+        # Test branch with empty commit object
+        feature_branch = branches[2]
+        assert feature_branch.name == 'feature-branch'
+        assert feature_branch.commit_sha == ''
+        assert feature_branch.last_push_date is None
+
+
+@pytest.mark.asyncio
+async def test_gitea_response_structure_handling():
+    """Test handling of different response structures (array vs object with data)."""
+    service = GiteaService(user_id=None, token=SecretStr('test-token'))
+
+    # Test array response
+    mock_array_response = [
+        {
+            'id': 123,
+            'full_name': 'test-user/test-repo',
+            'private': False,
+            'stars_count': 10,
+            'updated_at': '2023-01-01T00:00:00Z',
+            'owner': {'type': 'User'},
+            'default_branch': 'main',
+        }
+    ]
+
+    with patch.object(service, '_make_request', return_value=(mock_array_response, {})):
+        repositories = await service.get_all_repositories('updated', AppMode.SAAS)
+        assert len(repositories) == 1
+
+    # Test object response with data array
+    mock_object_response = {
+        'data': [
+            {
+                'id': 456,
+                'full_name': 'test-user/another-repo',
+                'private': True,
+                'stars_count': 5,
+                'updated_at': '2023-01-02T00:00:00Z',
+                'owner': {'type': 'User'},
+                'default_branch': 'master',
+            }
+        ]
+    }
+
+    with patch.object(
+        service, '_make_request', return_value=(mock_object_response, {})
+    ):
+        repositories = await service.get_all_repositories('updated', AppMode.SAAS)
+        assert len(repositories) == 1
+        assert repositories[0].id == '456'
+
+
+@pytest.mark.asyncio
+async def test_gitea_suggested_tasks_error_handling():
+    """Test error handling in suggested tasks retrieval."""
+    service = GiteaService(user_id=None, token=SecretStr('test-token'))
+
+    # Mock repositories
+    mock_repos = [
+        Repository(
+            id='123',
+            full_name='test-user/test-repo',
+            git_provider=ProviderType.GITEA,
+            is_public=True,
+            stargazers_count=10,
+            owner_type=OwnerType.USER,
+            main_branch='main',
+        )
+    ]
+
+    with patch.object(service, 'get_all_repositories', return_value=mock_repos):
+        with patch.object(service, '_make_request', side_effect=Exception('API Error')):
+            # Should not raise exception, but return empty list
+            tasks = await service.get_suggested_tasks()
+            assert tasks == []
+
+
+@pytest.mark.asyncio
+async def test_gitea_suggested_tasks_invalid_data():
+    """Test handling of invalid data in suggested tasks."""
+    service = GiteaService(user_id=None, token=SecretStr('test-token'))
+
+    mock_repos = [
+        Repository(
+            id='123',
+            full_name='test-user/test-repo',
+            git_provider=ProviderType.GITEA,
+            is_public=True,
+            stargazers_count=10,
+            owner_type=OwnerType.USER,
+            main_branch='main',
+        )
+    ]
+
+    # Mock issues with missing required fields
+    mock_issues = [
+        {'number': 1, 'title': 'Valid issue'},
+        {'number': None, 'title': 'Invalid issue - no number'},
+        {'number': 2, 'title': None},  # Invalid issue - no title
+        {'title': 'Invalid issue - no number field'},
+    ]
+
+    mock_prs = [
+        {'number': 3, 'title': 'Valid PR'},
+        {'number': None, 'title': 'Invalid PR'},
+    ]
+
+    with patch.object(service, 'get_all_repositories', return_value=mock_repos):
+        with patch.object(service, '_make_request') as mock_request:
+            mock_request.side_effect = [
+                (mock_issues, {}),
+                (mock_prs, {}),
+            ]
+
+            tasks = await service.get_suggested_tasks()
+
+            # Should only include valid tasks
+            assert len(tasks) == 2
+            assert all(task.issue_number is not None for task in tasks)
+            assert all(task.title is not None for task in tasks)
+
+
+@pytest.mark.asyncio
+async def test_gitea_pagination_limits():
+    """Test pagination limits are properly enforced."""
+    service = GiteaService(user_id=None, token=SecretStr('test-token'))
+
+    with patch.object(service, '_make_request') as mock_request:
+        mock_request.return_value = ([], {})
+
+        # Test that per_page is limited to 100
+        await service.get_paginated_repos(
+            page=1, per_page=150, sort='updated', installation_id=None
+        )
+
+        # Verify the request was made with limit=100 (Gitea's max)
+        call_args = mock_request.call_args
+        params = call_args[0][1]  # Second argument is params
+        assert params['limit'] == 100
+
+
+@pytest.mark.asyncio
+async def test_gitea_convert_to_repository():
+    """Test repository data conversion."""
+    service = GiteaService(user_id=None, token=SecretStr('test-token'))
+
+    # Test user repository
+    user_repo_data = {
+        'id': 123,
+        'full_name': 'test-user/test-repo',
+        'private': False,
+        'stars_count': 10,
+        'updated_at': '2023-01-01T00:00:00Z',
+        'owner': {'type': 'User'},
+        'default_branch': 'main',
+    }
+
+    repo = service._convert_to_repository(user_repo_data)
+    assert repo.id == '123'
+    assert repo.full_name == 'test-user/test-repo'
+    assert repo.git_provider == ProviderType.GITEA
+    assert repo.is_public is True
+    assert repo.stargazers_count == 10
+    assert repo.owner_type == OwnerType.USER
+    assert repo.main_branch == 'main'
+
+    # Test organization repository
+    org_repo_data = {
+        'id': 456,
+        'full_name': 'test-org/org-repo',
+        'private': True,
+        'stars_count': 25,
+        'updated_at': '2023-01-02T00:00:00Z',
+        'owner': {'type': 'Organization'},
+        'default_branch': 'develop',
+    }
+
+    repo = service._convert_to_repository(org_repo_data)
+    assert repo.owner_type == OwnerType.ORGANIZATION
+    assert repo.is_public is False
+    assert repo.main_branch == 'develop'
+
+    # Test repository with missing optional fields
+    minimal_repo_data = {
+        'id': 789,
+        'full_name': 'test-user/minimal-repo',
+        'owner': {},  # Missing type
+    }
+
+    repo = service._convert_to_repository(minimal_repo_data)
+    assert repo.id == '789'
+    assert repo.owner_type == OwnerType.USER  # Default fallback
+    assert repo.stargazers_count == 0  # Default value
+    assert repo.main_branch == 'main'  # Default value
